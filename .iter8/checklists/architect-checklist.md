# 架构师解决方案验证清单

本清单为架构师提供了一个全面的框架，用于在开发执行前验证技术设计和架构。架构师应系统地审阅每个项目，确保架构的健壮性、可扩展性、安全性，并与产品需求保持一致。

[[LLM: 初始化指令 - 必需文档

在开始此清单之前，请确保你已获取以下文档：

1. `architecture.md` - 主要架构文档 (检查 `docs/architecture.md`)
2. `prd.md` - 产品需求文档，用于需求对齐 (检查 `docs/prd.md`)
3. `frontend-architecture.md` 或 `fe-architecture.md` - 如果是 UI 项目 (检查 `docs/frontend-architecture.md`)
4. 架构中引用的任何系统图
5. 可用的 API 文档
6. 技术栈详情和版本规范

重要提示：如果任何必需文档缺失或无法访问，请立即向用户询问其位置或内容，然后再继续。

项目类型检测：
首先，通过检查以下内容确定项目类型：

- 架构是否包含前端/UI 组件？
- 是否存在 `frontend-architecture.md` 文档？
- PRD 是否提及用户界面或前端需求？

如果这是一个纯后端或纯服务项目：

- 跳过标记为 [[仅前端]] 的部分
- 重点关注 API 设计、服务架构和集成模式
- 在最终报告中注明，由于项目类型原因，已跳过前端部分

验证方法：
对于每个部分，你必须：

1. 深入分析 - 不要只是勾选，要根据提供的文档彻底分析每个项目
2. 基于证据 - 验证时引用文档中的特定部分或引文
3. 批判性思维 - 质疑假设并识别差距，而不仅仅是确认已有的内容
4. 风险评估 - 考虑每个架构决策可能出现的问题

执行模式：
询问用户希望如何进行清单审查：

- 逐节进行 (交互模式) - 审查每个部分，展示发现，获得确认后再继续
- 一次性完成 (全面模式) - 完成全部分析并在最后提交综合报告]]

## 1. 需求对齐

[[LLM: 在评估本节之前，请花时间充分理解 PRD 中的产品目的和目标。要解决的核心问题是什么？用户是谁？关键成功因素是什么？在验证对齐性时，请牢记这些。对于每个项目，不要只检查是否提及，要验证架构是否提供了具体的技术解决方案。]]

### 1.1 功能性需求覆盖

- [ ] 架构支持 PRD 中的所有功能性需求
- [ ] 所有史诗和故事的技术方法都已解决
- [ ] 考虑了边缘案例和性能场景
- [ ] 所有必需的集成都已考虑在内
- [ ] 用户旅程得到技术架构的支持

### 1.2 非功能性需求对齐

- [ ] 性能需求通过具体解决方案得到解决
- [ ] 可扩展性考虑已记录并附有方法
- [ ] 安全需求有相应的技术控制
- [ ] 可靠性和弹性方法已定义
- [ ] 合规性需求有技术实现

### 1.3 技术约束遵守

- [ ] 满足 PRD 中的所有技术约束
- [ ] 遵循平台/语言要求
- [ ] 基础设施约束得到满足
- [ ] 第三方服务约束得到解决
- [ ] 遵循组织的技术标准

## 2. 架构基础

[[LLM: 架构的清晰度对于成功实施至关重要。在审阅本节时，请想象一下你正在向一位新开发人员解释该系统。是否存在任何可能导致误解的模糊之处？AI 代理是否能够在没有困惑的情况下实现此架构？寻找具体的图表、组件定义和清晰的交互模式。]]

### 2.1 架构清晰度

- [ ] 架构通过清晰的图表进行记录
- [ ] 定义了主要组件及其职责
- [ ] 映射了组件交互和依赖关系
- [ ] 清晰地说明了数据流
- [ ] 指定了每个组件的技术选型

### 2.2 关注点分离

- [ ] UI、业务逻辑和数据层之间有清晰的边界
- [ ] 职责在组件之间清晰划分
- [ ] 组件之间的接口定义良好
- [ ] 组件遵守单一职责原则
- [ ] 横切关注点（日志、认证等）得到妥善处理

### 2.3 设计模式与最佳实践

- [ ] 采用了适当的设计模式
- [ ] 遵循了行业最佳实践
- [ ] 避免了反模式
- [ ] 整个架构风格一致
- [ ] 对模式的使用进行了记录和解释

### 2.4 模块化与可维护性

- [ ] 系统被划分为内聚、松耦合的模块
- [ ] 组件可以独立开发和测试
- [ ] 变更可以本地化到特定组件
- [ ] 代码组织促进了可发现性
- [ ] 架构专为 AI 代理实现而设计

## 3. 技术栈与决策

[[LLM: 技术选择具有长期影响。对于每个技术决策，请考虑：这是可行的最简单解决方案吗？我们是否过度设计了？这能否扩展？维护方面的影响是什么？所选版本是否存在安全漏洞？验证定义的版本是具体的，而不是范围。]]

### 3.1 技术选型

- [ ] 所选技术满足所有要求
- [ ] 技术版本已明确定义（非范围）
- [ ] 技术选择有明确的理由支持
- [ ] 记录了考虑过的备选方案及其优缺点
- [ ] 所选技术栈组件协同工作良好

### 3.2 前端架构 [[仅前端]]

[[LLM: 如果这是纯后端或纯服务项目，请跳过整个部分。仅当项目包含用户界面时才进行评估。]]

- [ ] 明确选择了 UI 框架和库
- [ ] 定义了状态管理方法
- [ ] 指定了组件结构和组织方式
- [ ] 概述了响应式/自适应设计方法
- [ ] 确定了构建和打包策略

### 3.3 后端架构

- [ ] 定义了 API 设计和标准
- [ ] 服务组织和边界清晰
- [ ] 指定了认证和授权方法
- [ ] 概述了错误处理策略
- [ ] 定义了后端扩展方法

### 3.4 数据架构

- [ ] 数据模型已完全定义
- [ ] 数据库技术已选定并附有理由
- [ ] 记录了数据访问模式
- [ ] 指定了数据迁移/种子数据方法
- [ ] 概述了数据备份和恢复策略

## 4. 前端设计与实现 [[仅前端]]

[[LLM: 对于纯后端项目，应跳过整个部分。仅当项目包含用户界面时才进行评估。评估时，请确保主架构文档和前端特定架构文档之间的一致性。]]

### 4.1 前端理念与模式

- [ ] 框架和核心库与主架构文档一致
- [ ] 组件架构（例如，原子设计）有清晰描述
- [ ] 状态管理策略适合应用程序的复杂性
- [ ] 数据流模式一致且清晰
- [ ] 定义了样式方法并指定了工具

### 4.2 前端结构与组织

- [ ] 使用 ASCII 图清晰记录了目录结构
- [ ] 组件组织遵循既定模式
- [ ] 文件命名约定明确
- [ ] 结构支持所选框架的最佳实践
- [ ] 对于新组件应放置在何处有明确指导

### 4.3 组件设计

- [ ] 定义了组件模板/规范格式
- [ ] 组件的 props、state 和 events 有良好文档记录
- [ ] 识别了共享/基础组件
- [ ] 建立了组件可重用性模式
- [ ] 可访问性要求内置于组件设计中

### 4.4 前后端集成

- [ ] 清晰定义了 API 交互层
- [ ] 记录了 HTTP 客户端的设置和配置
- [ ] API 调用的错误处理是全面的
- [ ] 服务定义遵循一致的模式
- [ ] 与后端的认证集成清晰

### 4.5 路由与导航

- [ ] 指定了路由策略和库
- [ ] 路由定义表是全面的
- [ ] 定义了路由保护机制
- [ ] 解决了深度链接的考虑
- [ ] 导航模式一致

### 4.6 前端性能

- [ ] 定义了图像优化策略
- [ ] 记录了代码分割方法
- [ ] 建立了懒加载模式
- [ ] 指定了重新渲染优化技术
- [ ] 定义了性能监控方法

## 5. 弹性与运营准备

[[LLM: 生产系统会以意想不到的方式失败。在审阅本节时，请思考墨菲定律——什么可能出错？考虑真实场景：高峰负载时会发生什么？当关键服务宕机时系统如何表现？运营团队能否在凌晨 3 点诊断问题？寻找具体的弹性模式，而不仅仅是提及“错误处理”。]]

### 5.1 错误处理与弹性

- [ ] 错误处理策略是全面的
- [ ] 在适当的地方定义了重试策略
- [ ] 为关键服务指定了断路器或回退机制
- [ ] 定义了优雅降级方法
- [ ] 系统可以从部分故障中恢复

### 5.2 监控与可观察性

- [ ] 定义了日志记录策略
- [ ] 指定了监控方法
- [ ] 识别了系统健康状况的关键指标
- [ ] 概述了警报阈值和策略
- [ ] 内置了调试和故障排除功能

### 5.3 性能与扩展

- [ ] 识别并解决了性能瓶颈
- [ ] 在适当的地方定义了缓存策略
- [ ] 指定了负载均衡方法
- [ ] 概述了水平和垂直扩展策略
- [ ] 提供了资源规模建议

### 5.4 部署与 DevOps

- [ ] 定义了部署策略
- [ ] 概述了 CI/CD 管道方法
- [ ] 指定了环境策略（开发、预发、生产）
- [ ] 定义了基础设施即代码（IaC）方法
- [ ] 概述了回滚和恢复程序

## 6. 安全与合规

[[LLM: 安全不是可选项。以黑客的思维方式审阅本节——有人会如何利用这个系统？同时考虑合规性：是否存在适用的行业特定法规？GDPR？HIPAA？PCI？确保架构主动解决了这些问题。寻找具体的安全控制措施，而不仅仅是泛泛而谈。]]

### 6.1 认证与授权

- [ ] 明确定义了认证机制
- [ ] 指定了授权模型
- [ ] 如果需要，概述了基于角色的访问控制（RBAC）
- [ ] 定义了会话管理方法
- [ ] 解决了凭证管理问题

### 6.2 数据安全

- [ ] 指定了数据加密方法（静态和传输中）
- [ ] 定义了敏感数据处理程序
- [ ] 概述了数据保留和清除策略
- [ ] 如果需要，解决了备份加密问题
- [ ] 如果需要，指定了数据访问审计跟踪

### 6.3 API 与服务安全

- [ ] 定义了 API 安全控制
- [ ] 指定了速率限制和节流方法
- [ ] 概述了输入验证策略
- [ ] 解决了 CSRF/XSS 预防措施
- [ ] 指定了安全通信协议

### 6.4 基础设施安全

- [ ] 概述了网络安全设计
- [ ] 指定了防火墙和安全组配置
- [ ] 定义了服务隔离方法
- [ ] 应用了最小权限原则
- [ ] 概述了安全监控策略

## 7. 实施指南

[[LLM: 清晰的实施指南可以防止代价高昂的错误。在审阅本节时，请想象你是一名第一天入职的开发人员。他们是否拥有高效工作所需的一切？编码标准是否足够清晰以保持团队间的一致性？寻找具体的示例和模式。]]

### 7.1 编码标准与实践

- [ ] 定义了编码标准
- [ ] 指定了文档要求
- [ ] 概述了测试期望
- [ ] 定义了代码组织原则
- [ ] 指定了命名约定

### 7.2 测试策略

- [ ] 定义了单元测试方法
- [ ] 概述了集成测试策略
- [ ] 指定了端到端（E2E）测试方法
- [ ] 概述了性能测试要求
- [ ] 定义了安全测试方法

### 7.3 前端测试 [[仅前端]]

[[LLM: 对于纯后端项目，请跳过此小节。]]

- [ ] 定义了组件测试范围和工具
- [ ] 指定了 UI 集成测试方法
- [ ] 考虑了视觉回归测试
- [ ] 识别了可访问性测试工具
- [ ] 解决了前端特定的测试数据管理问题

### 7.4 开发环境

- [ ] 记录了本地开发环境的设置
- [ ] 指定了所需的工具和配置
- [ ] 概述了开发工作流程
- [ ] 定义了源代码控制实践
- [ ] 指定了依赖管理方法

### 7.5 技术文档

- [ ] 定义了 API 文档标准
- [ ] 指定了架构文档要求
- [ ] 概述了代码文档期望
- [ ] 包括了系统图和可视化
- [ ] 包括了关键选择的决策记录

## 8. 依赖与集成管理

[[LLM: 依赖项通常是生产问题的根源。对于每个依赖项，请考虑：如果它不可用会怎样？是否有带安全补丁的新版本？我们是否被供应商锁定？我们的应急计划是什么？验证具体的版本和回退策略。]]

### 8.1 外部依赖

- [ ] 识别了所有外部依赖项
- [ ] 定义了依赖项的版本控制策略
- [ ] 指定了关键依赖项的回退方法
- [ ] 解决了许可影响问题
- [ ] 概述了更新和补丁策略

### 8.2 内部依赖

- [ ] 清晰映射了组件依赖关系
- [ ] 解决了构建顺序依赖问题
- [ ] 识别了共享服务和工具
- [ ] 消除了循环依赖
- [ ] 定义了内部组件的版本控制策略

### 8.3 第三方集成

- [ ] 识别了所有第三方集成
- [ ] 定义了集成方法
- [ ] 解决了与第三方的认证问题
- [ ] 指定了集成失败的错误处理
- [ ] 考虑了速率限制和配额

## 9. AI 代理实施适用性

[[LLM: 此架构可能由 AI 代理实施。审阅时要格外注重清晰度。模式是否一致？复杂性是否最小化？AI 代理是否会做出错误的假设？请记住：明确优于隐含。寻找清晰的文件结构、命名约定和实施模式。]]

### 9.1 面向 AI 代理的模块化

- [ ] 组件大小适合 AI 代理实施
- [ ] 组件之间的依赖关系最小化
- [ ] 定义了组件之间的清晰接口
- [ ] 组件具有单一、明确定义的职责
- [ ] 文件和代码组织为 AI 代理理解而优化

### 9.2 清晰性与可预测性

- [ ] 模式一致且可预测
- [ ] 复杂逻辑被分解为更简单的步骤
- [ ] 架构避免了过于聪明或晦涩的方法
- [ ] 为不熟悉的模式提供了示例
- [ ] 组件职责明确清晰

### 9.3 实施指南

- [ ] 提供了详细的实施指南
- [ ] 定义了代码结构模板
- [ ] 记录了具体的实施模式
- [ ] 识别了常见陷阱并提供了解决方案
- [ ] 在有帮助时提供了对类似实现的引用

### 9.4 错误预防与处理

- [ ] 设计减少了实施错误的机会
- [ ] 定义了验证和错误检查方法
- [ ] 在可能的情况下集成了自我修复机制
- [ ] 清晰定义了测试模式
- [ ] 提供了调试指南

## 10. 可访问性实现 [[仅前端]]

[[LLM: 对于纯后端项目，请跳过本节。可访问性是任何用户界面的核心要求。]]

### 10.1 可访问性标准

- [ ] 强调了语义化 HTML 的使用
- [ ] 提供了 ARIA 实现指南
- [ ] 定义了键盘导航要求
- [ ] 指定了焦点管理方法
- [ ] 解决了屏幕阅读器的兼容性问题

### 10.2 可访问性测试

- [ ] 识别了可访问性测试工具
- [ ] 将测试流程集成到工作流中
- [ ] 指定了合规性目标（WCAG 级别）
- [ ] 定义了手动测试程序
- [ ] 概述了自动化测试方法

[[LLM: 最终验证报告生成

既然你已经完成了清单，请生成一份全面的验证报告，包括：

1.  执行摘要

    -   整体架构就绪度（高/中/低）
    -   识别出的关键风险
    -   架构的主要优势
    -   项目类型（全栈/前端/后端）及评估的部分

2.  分节分析

    -   每个主要部分的通过率（通过项的百分比）
    -   最令人担忧的失败或差距
    -   需要立即关注的部分
    -   注明因项目类型而跳过的任何部分

3.  风险评估

    -   按严重性排列的前 5 大风险
    -   每个风险的缓解建议
    -   解决问题对时间线的影响

4.  建议

    -   开发前必须修复的项目
    -   为提高质量应修复的项目
    -   锦上添花的改进

5.  AI 实施就绪度

    -   对 AI 代理实施的具体担忧
    -   需要额外澄清的领域
    -   需要解决的复杂性热点

6.  前端特定评估（如适用）
    -   前端架构的完整性
    -   主架构和前端架构文档之间的一致性
    -   UI/UX 规范的覆盖范围
    -   组件设计的清晰度

在提交报告后，询问用户是否希望对任何特定部分进行详细分析，特别是那些有警告或失败的部分。]]