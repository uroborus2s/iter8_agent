# {{项目名称}} 架构文档

[[LLM: 如果可用，请在开始之前审查任何提供的相关文档以收集所有相关背景。如果至少无法找到 `docs/prd.md`，请询问用户将为架构提供基础的文档。]]

[[LLM: 除非另有说明，默认路径和文件名为 docs/architecture.md]]

## 简介

[[LLM: 本节建立文档的目的和范围。保留以下内容，但确保项目名称被正确替换。

呈现本节后，应用 `tasks#advanced-elicitation` 协议]]

本文档概述了{{项目名称}}的整体项目架构，包括后端系统、共享服务和非UI特定关注点。其主要目标是作为AI驱动开发的指导性架构蓝图，确保一致性并遵循选定的模式和技术。

**与前端架构的关系:**
如果项目包含重要的用户界面，单独的前端架构文档将详细说明前端特定的设计，必须与本文档结合使用。此处记录的核心技术栈选择（见"技术栈"）对整个项目具有决定性意义，包括任何前端组件。

### 起始模板或现有项目

[[LLM: 在进一步进行架构设计之前，检查项目是否基于起始模板或现有代码库：

1. 审查PRD和头脑风暴简介中是否提到：

- 起始模板（例如，Create React App、Next.js、Vue CLI、Angular CLI等）
- 现有项目或作为基础的代码库
- 样板项目或脚手架工具
- 要克隆或改编的先前项目

2. 如果提到起始模板或现有项目：

- 要求用户通过以下方法之一提供访问权限：
  - 起始模板文档的链接
  - 上传/附加项目文件（对于小项目）
  - 分享项目仓库的链接（GitHub、GitLab等）
- 分析起始/现有项目以了解：
  - 预配置的技术栈和版本
  - 项目结构和组织模式
  - 内置脚本和工具
  - 现有的架构模式和约定
  - 起始项目施加的任何限制或约束
- 使用此分析来指导和对齐您的架构决策

3. 如果没有提到起始模板但这是绿地项目：

- 根据技术栈偏好建议适当的起始模板
- 解释好处（更快的设置、最佳实践、社区支持）
- 让用户决定是否使用

4. 如果用户确认不会使用起始模板：

- 从头开始进行架构设计
- 注意需要手动设置所有工具和配置

在继续架构设计之前，请在此处记录决定。如果没有，只需说明N/A

呈现此起始模板部分后，应用 `tasks#advanced-elicitation` 协议]]

### 变更日志

[[LLM: 跟踪文档版本和变更]]

| 日期 | 版本 | 描述 | 作者 |
| :--- | :------ | :---------- | :----- |

## 高层架构

[[LLM: 本节包含建立架构基础的多个子节。将所有子节一起呈现（简介、技术摘要、高层概述、项目图表和架构模式），然后对完整的高层架构部分应用 `tasks#advanced-elicitation` 协议。用户可以选择完善整个部分或特定的子节。]]

### 技术摘要

[[LLM: 提供简要的段落（3-5句话）概述：

- 系统的整体架构风格
- 关键组件及其关系
- 主要技术选择
- 使用的核心架构模式
- 参考PRD目标以及此架构如何支持它们]]

### 高层概述

[[LLM: 基于PRD的技术假设部分，描述：

1. 主要架构风格（例如，单体、微服务、无服务器、事件驱动）
2. PRD中的仓库结构决定（单体仓库/多仓库）
3. PRD中的服务架构决定
4. 概念层面的主要用户交互流或数据流
5. 关键架构决策及其理由

呈现本节后，应用 `tasks#advanced-elicitation` 协议]]

### 高层项目图表

[[LLM: 创建一个Mermaid图表来可视化高层架构。考虑：

- 系统边界
- 主要组件/服务
- 数据流方向
- 外部集成
- 用户入口点

根据最能代表架构的内容使用适当的Mermaid图表类型（graph TD、C4、sequence）

呈现图表后，应用 `tasks#advanced-elicitation` 协议]]

### 架构和设计模式

[[LLM: 列出指导架构的关键高层模式。对于每个模式：

1. 如果存在多个选项，呈现2-3个可行选项
2. 提供明确理由的推荐
3. 在最终确定之前获得用户确认
4. 这些模式应与PRD的技术假设和项目目标保持一致

要考虑的常见模式：

- 架构风格模式（无服务器、事件驱动、微服务、CQRS、六边形）
- 代码组织模式（依赖注入、仓库、模块、工厂）
- 数据模式（事件溯源、Saga、每服务数据库）
- 通信模式（REST、GraphQL、消息队列、发布/订阅）]]

<<REPEAT: pattern>>

- **{{模式名称}}:** {{模式描述}} - _理由:_ {{理由}}

<</REPEAT>>

@{示例: 模式}

- **无服务器架构:** 使用AWS Lambda进行计算 - _理由:_ 符合PRD对成本优化和自动扩展的要求
- **仓库模式:** 抽象数据访问逻辑 - _理由:_ 支持测试和未来数据库迁移的灵活性
- **事件驱动通信:** 使用SNS/SQS进行服务解耦 - _理由:_ 支持异步处理和系统弹性

@{/示例}

[[LLM: 呈现模式后，应用 `tasks#advanced-elicitation` 协议]]

## 技术栈

[[LLM: 这是确定性的技术选择部分。与用户合作做出具体选择：

1. 审查PRD技术假设和来自 `data#technical-preferences` 或附加的 `technical-preferences` 的任何偏好
2. 对于每个类别，呈现2-3个可行选项及其优缺点
3. 基于项目需求做出明确推荐
4. 获得每个选择的明确用户批准
5. 记录确切版本（避免"最新" - 固定特定版本）
6. 此表是唯一的真实来源 - 所有其他文档必须引用这些选择

要最终确定的关键决策 - 在显示表格之前，确保您了解或询问用户 - 如果他们不确定任何内容，请让用户知道您也可以提供带有理由的建议：

- 起始模板（如果有）
- 语言和运行时与确切版本
- 框架和库/包
- 云提供商和关键服务选择
- 数据库和存储解决方案 - 如果不清楚，根据项目建议sql或nosql或其他类型，根据云提供商提供建议
- 开发工具

渲染表格时，确保用户了解此部分选择的重要性，还应查找差距或与列表中任何内容的分歧，如果不清楚为什么在列表中请要求任何澄清，并且也立即应用 `tasks#advanced-elicitation` 显示 - 此声明和选项应在允许用户输入之前立即呈现和提示。]]

### 云基础设施

- **提供商:** {{云提供商}}
- **关键服务:** {{核心服务列表}}
- **部署区域:** {{区域}}

### 技术栈表

| 类别           | 技术         | 版本     | 目的     | 理由      |
| :----------------- | :----------------- | :---------- | :---------- | :------------- |
| **语言**       | {{语言}}       | {{版本}} | {{目的}} | {{选择原因}} |
| **运行时**        | {{运行时}}        | {{版本}} | {{目的}} | {{选择原因}} |
| **框架**      | {{框架}}      | {{版本}} | {{目的}} | {{选择原因}} |
| **数据库**       | {{数据库}}       | {{版本}} | {{目的}} | {{选择原因}} |
| **缓存**          | {{缓存}}          | {{版本}} | {{目的}} | {{选择原因}} |
| **消息队列**  | {{队列}}          | {{版本}} | {{目的}} | {{选择原因}} |
| **API风格**      | {{API风格}}      | {{版本}} | {{目的}} | {{选择原因}} |
| **身份验证** | {{认证}}           | {{版本}} | {{目的}} | {{选择原因}} |
| **测试**        | {{测试框架}} | {{版本}} | {{目的}} | {{选择原因}} |
| **构建工具**     | {{构建工具}}     | {{版本}} | {{目的}} | {{选择原因}} |
| **IaC工具**       | {{IaC工具}}       | {{版本}} | {{目的}} | {{选择原因}} |
| **监控**     | {{监控}}     | {{版本}} | {{目的}} | {{选择原因}} |
| **日志**        | {{日志}}        | {{版本}} | {{目的}} | {{选择原因}} |

@{示例: 技术栈行}
| **语言** | TypeScript | 5.3.3 | 主要开发语言 | 强类型、优秀工具、团队专业知识 |
| **运行时** | Node.js | 20.11.0 | JavaScript运行时 | LTS版本、稳定性能、广泛生态系统 |
| **框架** | NestJS | 10.3.2 | 后端框架 | 企业就绪、良好的DI、匹配团队模式 |
@{/示例}

## 数据模型

[[LLM: 定义核心数据模型/实体：

1. 审查PRD需求并识别关键业务实体
2. 对于每个模型，解释其目的和关系
3. 包含关键属性和数据类型
4. 显示模型之间的关系
5. 与用户讨论设计决策

在移至数据库模式之前创建清晰的概念模型。

呈现所有数据模型后，应用 `tasks#advanced-elicitation` 协议]]

<<REPEAT: 数据模型>>

### {{模型名称}}

**目的:** {{模型目的}}

**关键属性:**

- {{属性1}}: {{类型1}} - {{描述1}}
- {{属性2}}: {{类型2}} - {{描述2}}

**关系:**

- {{关系1}}
- {{关系2}}
<</REPEAT>>

## 组件

[[LLM: 基于上述架构模式、技术栈和数据模型：

1. 识别主要逻辑组件/服务及其职责
2. 考虑PRD中的仓库结构（单体仓库/多仓库）
3. 定义组件之间的清晰边界和接口
4. 对于每个组件，指定：

- 主要职责
- 暴露的关键接口/API
- 对其他组件的依赖
- 基于技术栈选择的技术细节

5. 在有帮助的地方创建组件图表
6. 呈现所有组件后，应用 `tasks#advanced-elicitation` 协议]]

<<REPEAT: 组件>>

### {{组件名称}}

**职责:** {{组件描述}}

**关键接口:**

- {{接口1}}
- {{接口2}}

**依赖:** {{依赖}}

**技术栈:** {{组件技术细节}}
<</REPEAT>>

### 组件图表

[[LLM: 创建Mermaid图表来可视化组件关系。选项：

- 高层视图的C4容器图
- 详细内部结构的组件图
- 复杂交互的序列图
选择最适合清晰度的

呈现图表后，应用 `tasks#advanced-elicitation` 协议]]

## 外部API

[[LLM: 对于每个外部服务集成：

1. 基于PRD需求和组件设计识别所需的API
2. 如果文档URL未知，请询问用户具体信息
3. 记录身份验证方法和安全考虑
4. 列出将使用的特定端点
5. 注意任何速率限制或使用约束

如果不需要外部API，明确说明并跳到下一节。]]

^^CONDITION: has_external_apis^^

<<REPEAT: 外部API>>

### {{API名称}} API

- **目的:** {{API目的}}
- **文档:** {{API文档URL}}
- **基础URL:** {{API基础URL}}
- **身份验证:** {{认证方法}}
- **速率限制:** {{速率限制}}

**使用的关键端点:**
<<REPEAT: 端点>>

- `{{方法}} {{端点路径}}` - {{端点目的}}
<</REPEAT>>

**集成注意事项:** {{集成考虑}}
<</REPEAT>>

@{示例: 外部API}

### Stripe API

- **目的:** 支付处理和订阅管理
- **文档:** https://stripe.com/docs/api
- **基础URL:** `https://api.stripe.com/v1`
- **身份验证:** 使用密钥的Bearer令牌
- **速率限制:** 每秒100个请求

**使用的关键端点:**

- `POST /customers` - 创建客户档案
- `POST /payment_intents` - 处理支付
- `POST /subscriptions` - 管理订阅
@{/示例}

^^/CONDITION: has_external_apis^^

[[LLM: 呈现外部API（或注意其缺失）后，应用 `tasks#advanced-elicitation` 协议]]

## 核心工作流

[[LLM: 使用序列图说明关键系统工作流：

1. 从PRD识别关键用户旅程
2. 显示包括外部API在内的组件交互
3. 包含错误处理路径
4. 记录异步操作
5. 根据需要创建高层和详细图表

专注于澄清架构决策或复杂交互的工作流。

呈现工作流图表后，应用 `tasks#advanced-elicitation` 协议]]

## REST API规范

[[LLM: 如果项目包含REST API：

1. 创建OpenAPI 3.0规范
2. 包含来自史诗/故事的所有端点
3. 基于数据模型定义请求/响应模式
4. 记录身份验证要求
5. 包含示例请求/响应

使用YAML格式以获得更好的可读性。如果没有REST API，跳过此节。]]

^^CONDITION: has_rest_api^^

```yaml
openapi: 3.0.0
info:
  title: {{项目名称}} API
  version: {{版本}}
  description: {{API描述}}
servers:
  - url: {{服务器URL}}
    description: {{服务器描述}}
```

^^/CONDITION: has_rest_api^^

[[LLM: 呈现REST API规范（或注意其缺失如果不适用）后，应用 `tasks#advanced-elicitation` 协议]]

## 数据库模式

[[LLM: 将概念数据模型转换为具体的数据库模式：

1. 使用技术栈中选择的数据库类型
2. 使用适当的符号创建模式定义
3. 包含索引、约束和关系
4. 考虑性能和可扩展性
5. 对于NoSQL，显示文档结构

以适合数据库类型的格式呈现模式（SQL DDL、JSON模式等）

呈现数据库模式后，应用 `tasks#advanced-elicitation` 协议]]

## 源代码树

[[LLM: 创建反映以下内容的项目文件夹结构：

1. 选择的仓库结构（单体仓库/多仓库）
2. 服务架构（单体/微服务/无服务器）
3. 选择的技术栈和语言
4. 上述组件组织
5. 选择框架的最佳实践
6. 关注点的清晰分离

根据项目需求调整结构。对于单体仓库，显示服务分离。对于无服务器，显示函数组织。包含特定语言的约定。

呈现结构后，应用 `tasks#advanced-elicitation` 协议以根据用户反馈进行完善。]]

```plaintext
{{项目根目录}}/
├── .github/                    # CI/CD工作流
│   └── workflows/
│       └── main.yml
├── .vscode/                    # VSCode设置（可选）
│   └── settings.json
├── build/                      # 编译输出（git忽略）
├── config/                     # 配置文件
├── docs/                       # 项目文档
│   ├── PRD.md
│   ├── architecture.md
│   └── ...
├── infra/                      # 基础设施即代码
│   └── {{IaC结构}}
├── {{依赖目录}}/       # 依赖（git忽略）
├── scripts/                    # 实用脚本
├── src/                        # 应用源代码
│   └── {{源代码结构}}
├── tests/                      # 测试文件
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── .env.example                # 环境变量模板
├── .gitignore                  # Git忽略规则
├── {{包清单}}        # 依赖清单
├── {{配置文件}}            # 语言/框架配置
└── README.md                   # 项目文档

@{示例: 单体仓库结构}
项目根目录/
├── packages/
│ ├── api/ # 后端API服务
│ ├── web/ # 前端应用
│ ├── shared/ # 共享实用程序/类型
│ └── infrastructure/ # IaC定义
├── scripts/ # 单体仓库管理脚本
└── package.json # 带工作区的根package.json
@{/示例}
```

[[LLM: 呈现源代码树结构后，应用 `tasks#advanced-elicitation` 协议]]

## 基础设施和部署

[[LLM: 定义部署架构和实践：

1. 使用技术栈中选择的IaC工具
2. 选择适合架构的部署策略
3. 定义环境和推广流程
4. 建立回滚程序
5. 考虑安全、监控和成本优化

获取用户对部署偏好和CI/CD工具选择的输入。]]

### 基础设施即代码

- **工具:** {{IaC工具}} {{版本}}
- **位置:** `{{IaC目录}}`
- **方法:** {{IaC方法}}

### 部署策略

- **策略:** {{部署策略}}
- **CI/CD平台:** {{CI/CD平台}}
- **管道配置:** `{{管道配置位置}}`

### 环境

<<REPEAT: 环境>>

- **{{环境名称}}:** {{环境目的}} - {{环境详情}}
<</REPEAT>>

### 环境推广流程

```text
{{推广流程图}}
```

### 回滚策略

- **主要方法:** {{回滚方法}}
- **触发条件:** {{回滚触发器}}
- **恢复时间目标:** {{RTO}}

[[LLM: 呈现基础设施和部署部分后，应用 `tasks#advanced-elicitation` 协议]]

## 错误处理策略

[[LLM: 定义全面的错误处理方法：

1. 为技术栈中的语言/框架选择适当的模式
2. 定义日志标准和工具
3. 建立错误类别和处理规则
4. 考虑可观察性和调试需求
5. 确保安全（日志中没有敏感数据）

本节指导AI和人类开发者进行一致的错误处理。]]

### 一般方法

- **错误模型:** {{错误模型}}
- **异常层次:** {{异常结构}}
- **错误传播:** {{传播规则}}

### 日志标准

- **库:** {{日志库}} {{版本}}
- **格式:** {{日志格式}}
- **级别:** {{日志级别定义}}
- **必需上下文:**
  - 关联ID: {{关联ID格式}}
  - 服务上下文: {{服务上下文}}
  - 用户上下文: {{用户上下文规则}}

### 错误处理模式

#### 外部API错误

- **重试策略:** {{重试策略}}
- **断路器:** {{断路器配置}}
- **超时配置:** {{超时设置}}
- **错误转换:** {{错误映射规则}}

#### 业务逻辑错误

- **自定义异常:** {{业务异常类型}}
- **面向用户的错误:** {{用户错误格式}}
- **错误代码:** {{错误代码系统}}

#### 数据一致性

- **事务策略:** {{事务方法}}
- **补偿逻辑:** {{补偿模式}}
- **幂等性:** {{幂等性方法}}

[[LLM: 呈现错误处理策略后，应用 `tasks#advanced-elicitation` 协议]]

## 编码标准

[[LLM: 这些标准对AI代理是强制性的。与用户合作定义仅防止坏代码所需的关键规则。解释：

1. 本节直接控制AI开发者行为
2. 保持最小 - 假设AI知道一般最佳实践
3. 专注于项目特定的约定和陷阱
4. 过于详细的标准会膨胀上下文并减慢开发
5. 标准将被提取到单独的文件供开发代理使用

对于每个标准，获得明确的用户确认其必要性。]]

### 核心标准

- **语言和运行时:** {{语言和版本}}
- **样式和检查:** {{检查器配置}}
- **测试组织:** {{测试文件约定}}

### 命名约定

[[LLM: 仅在偏离语言默认值时包含]]

| 元素   | 约定           | 示例           |
| :-------- | :------------------- | :---------------- |
| 变量 | {{变量约定}}   | {{变量示例}}   |
| 函数 | {{函数约定}}  | {{函数示例}}  |
| 类   | {{类约定}} | {{类示例}} |
| 文件     | {{文件约定}}  | {{文件示例}}  |

### 关键规则

[[LLM: 仅列出AI可能违反的规则或项目特定要求。示例：

- "生产代码中永远不要使用console.log - 使用日志记录器"
- "所有API响应必须使用ApiResponse包装器类型"
- "数据库查询必须使用仓库模式，永远不要直接ORM"

避免明显的规则，如"使用SOLID原则"或"编写干净代码"]]

<<REPEAT: 关键规则>>

- **{{规则名称}}:** {{规则描述}}
<</REPEAT>>

### 特定语言指南

[[LLM: 仅在防止AI错误的关键情况下添加。大多数团队不需要此节。]]

^^CONDITION: has_language_specifics^^

#### {{语言名称}} 特定

<<REPEAT: 语言规则>>

- **{{规则主题}}:** {{规则详情}}
<</REPEAT>>

^^/CONDITION: has_language_specifics^^

[[LLM: 呈现编码标准后，应用 `tasks#advanced-elicitation` 协议]]

## 测试策略和标准

[[LLM: 与用户合作定义全面的测试策略：

1. 使用技术栈中的测试框架
2. 决定TDD与后测试方法
3. 定义测试组织和命名
4. 建立覆盖率目标
5. 确定集成测试基础设施
6. 规划测试数据和外部依赖

注意：基本信息进入编码标准供开发代理使用。此详细部分用于QA代理和团队参考。初稿后应用 `tasks#advanced-elicitation`。]]

### 测试理念

- **方法:** {{测试方法}}
- **覆盖率目标:** {{覆盖率目标}}
- **测试金字塔:** {{测试分布}}

### 测试类型和组织

#### 单元测试

- **框架:** {{单元测试框架}} {{版本}}
- **文件约定:** {{单元测试命名}}
- **位置:** {{单元测试位置}}
- **模拟库:** {{模拟库}}
- **覆盖率要求:** {{单元覆盖率}}

**AI代理要求:**

- 为所有公共方法生成测试
- 覆盖边缘情况和错误条件
- 遵循AAA模式（安排、操作、断言）
- 模拟所有外部依赖

#### 集成测试

- **范围:** {{集成范围}}
- **位置:** {{集成测试位置}}
- **测试基础设施:**
  <<REPEAT: 测试依赖>>
  - **{{依赖名称}}:** {{测试方法}} ({{测试工具}})
  <</REPEAT>>

@{示例: 测试依赖}

- **数据库:** 单元测试使用内存H2，集成使用Testcontainers PostgreSQL
- **消息队列:** 测试使用嵌入式Kafka
- **外部API:** 使用WireMock进行存根
@{/示例}

#### 端到端测试

- **框架:** {{E2E框架}} {{版本}}
- **范围:** {{E2E范围}}
- **环境:** {{E2E环境}}
- **测试数据:** {{E2E数据策略}}

### 测试数据管理

- **策略:** {{测试数据方法}}
- **固定装置:** {{固定装置位置}}
- **工厂:** {{工厂模式}}
- **清理:** {{清理策略}}

### 持续测试

- **CI集成:** {{CI测试阶段}}
- **性能测试:** {{性能测试方法}}
- **安全测试:** {{安全测试方法}}

[[LLM: 呈现测试策略部分后，应用 `tasks#advanced-elicitation` 协议]]

## 安全

[[LLM: 为AI和人类开发者定义强制性安全要求：

1. 专注于实现特定规则
2. 引用技术栈中的安全工具
3. 为常见场景定义清晰模式
4. 这些规则直接影响代码生成
5. 与用户合作确保完整性而不冗余]]

### 输入验证

- **验证库:** {{验证库}}
- **验证位置:** {{验证位置}}
- **必需规则:**
  - 所有外部输入必须验证
  - 在处理前在API边界验证
  - 优先使用白名单方法而非黑名单

### 身份验证和授权

- **认证方法:** {{认证实现}}
- **会话管理:** {{会话方法}}
- **必需模式:**
  - {{认证模式1}}
  - {{认证模式2}}

### 密钥管理

- **开发:** {{开发密钥方法}}
- **生产:** {{生产密钥服务}}
- **代码要求:**
  - 永远不要硬编码密钥
  - 仅通过配置服务访问
  - 日志或错误消息中不得包含密钥

### API安全

- **速率限制:** {{速率限制实现}}
- **CORS策略:** {{CORS配置}}
- **安全头:** {{必需头}}
- **HTTPS强制:** {{HTTPS方法}}

### 数据保护

- **静态加密:** {{静态加密}}
- **传输加密:** {{传输加密}}
- **PII处理:** {{PII规则}}
- **日志限制:** {{不记录内容}}

### 依赖安全

- **扫描工具:** {{依赖扫描器}}
- **更新策略:** {{更新频率}}
- **批准流程:** {{新依赖流程}}

### 安全测试

- **SAST工具:** {{静态分析}}
- **DAST工具:** {{动态分析}}
- **渗透测试:** {{渗透测试计划}}

[[LLM: 呈现安全部分后，应用 `tasks#advanced-elicitation` 协议]]

## 清单结果报告

[[LLM: 在运行清单之前，提议输出完整的架构文档。一旦用户确认，执行 `architect-checklist` 并在此处填充结果。]]

---

## 下一步

[[LLM: 完成架构后：

1. 如果项目有UI组件：

- 推荐与设计架构师代理合作
- 使用"前端架构模式"
- 提供此文档作为输入

2. 对于所有项目：

- 推荐与产品负责人合作进行史诗和故事创建
- 使用此架构文档指导技术实现决策
- 确保所有开发代理都可以访问此文档]]

^^CONDITION: has_ui^^

### Design Architect Prompt

[[LLM: Create a brief prompt to hand off to Design Architect for Frontend Architecture creation. Include:

- Reference to this architecture document
- Key UI requirements from PRD
- Any frontend-specific decisions made here
- Request for detailed frontend architecture]]

^^/CONDITION: has_ui^^

### Developer Handoff

[[LLM: Create a brief prompt for developers starting implementation. Include:

- Reference to this architecture and coding standards
- First epic/story to implement
- Key technical decisions to follow]]